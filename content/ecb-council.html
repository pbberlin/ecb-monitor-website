<style>

  :root{
    --display-type:   desktop;               /* used in javascript, no quotation marks */

    --grad-height:   1.2rem;
    --w01:           max(20rem, 20vw);  /* width left and right column  */
    --w01-min:       calc( var(--w01) - 0.5rem )  ;
    --echartHeight:   75vh;              /* not 75% -  fails */
    --marginHeight:  calc( var(--echartHeight) - 1rem);
    --initOpacity:   0.6;               /* minimize flickering */

  }


  /* radio buttons 20% larger */
  input[type="radio"] {
    transform:         scale(1.34);
    -webkit-transform: scale(1.34);    /* Safari / older WebKit */
    -ms-transform:     scale(1.34);    /* old IE/Edge */
    transform-origin:  center;
    vertical-align:    middle;

    position: relative;
    top: -0.12rem;

  }


  input[type="radio"] {
    margin-left:  0.4rem;
  }

  html,
  body,
  dummy {
    height: 100%;
  }


  .layout h3 {
      font-size: 140%;
      text-align: left;
      text-align: center;
  }


  /*
    container: left-to-right flow, top-aligned
    3 columns
    - col 1: 20% - at least 20vm
    - col 2: exactly 820px
    - col 3: 1fr - takes remaining width
    -           or right margin max(20rem, 20vw)
  */
  .layout {
    width: calc( 820px + 2* var(--w01));
    margin: 0 auto;

    display: grid;
    grid-template-columns:  var(--w01) 820px  var(--w01);
    column-gap: 0;
    align-items: start;           /* vertical: top for all */

    /* border: 1px solid red; */
  }

  /* Ensure grid items can shrink if needed */
  .col {
    min-width: 0;
    padding:   0;
    margin:    0;
    /* margin: 2px; */
    /* border: 1px solid red; */
  }


  /* col1 - at least 20rem - 20% of screen width - */
  .col--left   {
    height:    var(--marginHeight);
    min-width: var(--w01-min);

    justify-self: end;
    align-self: start;
    text-align: right;
    /* width: max-content; */

    /* align-content:   end; */
  }

  /* col2 -  fixed 820px, content centered */
  .col--center {
    justify-self: center;
    align-self:    start;
  }

  /* col3 - takes the residual space, content left */
  .col--right  {
    height:    var(--marginHeight);
    min-width: var(--w01-min);
    /* width: max-content; */

    justify-self: start;
    align-self:   start;
    text-align:   left;

    align-content:   end;


  }


  #echart_container {

    /* not 100% -  fails */
    width: 820px;
    height: var(--echartHeight);

    /* margin:  0 auto; */
    padding: 0;
    border-bottom: 1px solid lightgray;
    /* border-right:  1px solid lightgray; */
    /* border: 1px solid lightgray; */
    box-sizing: border-box;
  }


  /* content styles, why was the z-index needed?  */
  .control-pad {
    position: relative;   /*  z-index  */
    z-index:  10;

    margin:  0.4rem;
    padding: 0.5rem 1.1rem;

    border-radius: 0.2rem;
    background-color: rgba(217,233,236,0.25);
  }

  .slider-group {
    display:        flex;
    flex-direction: column;
    gap:           0.01rem;
    align-items:   center;   /* contents centered horizontally */
    height:        auto;
    width:         max-content;    /* shrink container to content so it can sit right */
    width:         100%;

    margin-top:    1.1rem;
    margin-bottom: 1.1rem;
    margin-left:   auto;
    margin-right:  auto;
  }

  #yearSlider {
    width: 90%;
    align-self: end;
  }






@media (max-width: 900px) {
      /* smartphone */

      :root {
        /* also zooms the echart */
        --echartHeight:   34vh;
        --display-type:   mobile;               /* used in javascript, no quotation marks */
      }


      /* single column stack */
      .layout {
        width:     100%;
        max-width: 100%;

        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;  /* col--left, col--center, col--right */
      }

      /* allow cols to shrink nicely */
      .col {
        min-width: 0;
        padding:   0;
        margin:    0;
      }

      /* stacked: top, middle, bottom
        (HTML order already is: left -> center -> right) */
      .col--left,
      .col--center,
      .col--right {
        width:     100%;
        min-width:    0;
        height:    auto;

        justify-self: stretch;
        align-self:     start;
        text-align:    center;
      }

      .col--right {
        /* height: 20rem;  */
        height: auto;
        padding: 1rem 2rem;
        text-align: left;
      }


      /* center column: echart takes full width on phone */
      #echart_container {
        width:             100%;
        max-width:         100%;
        height:      var(--echartHeight);
        box-sizing: border-box;

        /* border-top: 2px solid red; */
      }


      .layout h3 {
        /* .layout to increase specifitiy */
        text-align: center;
        width:      90%;
        margin: 1rem auto ;
        margin-bottom: 0;
      }



}


  .col--left   {
    background-image: url("/static/img/ecb/ecb-transparent-22pct.png");
    background-image: url("/static/img/ecb/ecb-transparent-30pct.png");
    background-repeat: no-repeat;

    background-size:      100%;
    background-position-y:  4.8rem;
    background-position-x: -4.5rem;

    background-size:      70%;
    background-position-y:  5.8rem;
    background-position-x:  1.3rem;

    /* background-blend-mode: lighten; */
  }




</style>


<style>

  .gradientWrapper {
      position:    relative;
      height:      var(--grad-height);
      width:       100%;
      margin:      2rem 0;
      /* margin-top:  0; */
      /* border: 1px solid gray; */
  }

  .gradient1 {
      height:   var(--grad-height);
      width:    100%;
      opacity:  var(--initOpacity);

      /* background is set dynamically by JS */
  }


  .tick {
      position: absolute;

      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 0.4rem;

      height:  5px;
      width:   1px;
      top:     calc(var(--grad-height) + 0.0rem);

      background: black;
      text-align:   center;
      transform:    translateX(calc(-50% + 1px));
      font-size: 11px;
  }
  .tick:last-child {
      transform:    translateX(calc(-50% - 1px));
  }



  .gradientDebug {
      height:   var(--grad-height);
      width:    100%;
      opacity:  var(--initOpacity);
      background: linear-gradient(
          to right,
          #00A000   0%,
          #A08000  30%,
          #A08000  30%,
          #FF0000  90%,
          #FF0000 100%
      );
      /* border: 1px solid #444; */
  }


</style>




<style>

  #council_list {
    max-height: 90%;
  }

  #council_list .member-card {
    display: grid;
    grid-template-columns: 1fr auto;
    column-gap: 0.4rem;

    margin:  0;
    margin-bottom:  0.25rem;
    padding: 0;
  }

  #council_list .member-card div {
    margin:    0;
    padding:   0;
    /* font-size: 90%; */
  }

  #council_list .member-card div.name {
    font-weight: bold;
  }
  #council_list .member-card div.role_euro__from_to {
    position: relative;
    top:      -0.37rem;
  }


  #council_list .member-card div.name,
  #council_list .member-card div.role_euro__from_to {
      grid-column: 1;
  }
  #council_list .member-card div.hawkish_score  {

    position: relative;
    top:      -0.15rem;
    font-size: 130%;

    grid-column: 2;
    grid-row:    1 / span 2;

    /* align-self:   start; */
    align-self:   center;
    min-width:     3.3rem;    /* enough space for leading negative sign  */
    padding-right: 0.14rem;

    border-radius: 0.2rem;

  }






</style>








<div class="layout">

  <div class="col col--left control-pad">
      <!-- First (top, right) -->
      <h3> {{i18n.headline_ecb_council}}</h3>

      <!-- <label for="yearSlider">Year:</label> -->
      <div id="slider-group" class="slider-group">
        <input id="yearSlider" type="range" min="1998" step="1"  autofocus  />
        <span  id="yearLabel"  style="display: inline-block; position: relative;; left: 0.9rem;"></span>
      </div>


      <div id="council_list" ></div>

    </div>


  <div class="col col--center">
    <div id="echart_container">echart container content</div>
  </div>

  <div class="col col--right control-pad">
      <!-- right col content -->


      <style>
        .gradient-illustation {
          width: 17%;
        }
        .gradient-illustation-img1 {
          /* align-self:   start; */
          /* justify-self: start; */
          translate:  -40%  +60%;
        }
        .gradient-illustation-img2 {
          margin-left: auto;
          translate: +40%   +60%;
        }
      </style>

      <div class="slider-group"
          style="margin-top: 0.5rem; margin-bottom: 0;
          flex-direction: row;
          aa-border: 2px solid gray;"
      >

        <img class="gradient-illustation gradient-illustation-img1"  src="/static/img/dovish-hawkish/dove.png" alt="dove">
        <img class="gradient-illustation gradient-illustation-img2"  src="/static/img/dovish-hawkish/hawk.png" alt="hawk">

      </div>



      <div class="gradientWrapper">
          <div class="gradient1" id="gradient1"></div>
      </div>
      <!--
      <div class="gradientWrapper">
          <div class="gradientDebug" id="gradientDebug"></div>
          <div class="tick" style="left:   0px;">  0%</div>
          <div class="tick" style="left:   30%;"> 60%</div>
          <div class="tick" style="left:   50%;">100%</div>
          <div class="tick" style="left:  100%;">180%</div>
      </div>
      -->


      <div class="slider-group"
          style="margin-top: 4.5rem; margin-bottom: 0;"
          title="change  saturation / opacity of the map colors"
      >
        <span style="font-size: 65%; font-weight: 300; display: inline-block; position: relative; top: -5px;"
        >{{i18n.color_saturation}} </span>
        <input name="color_opacity" id="color_opacity" type="range" min="0" max="1" step="0.1"
          value="0.6"
          style="border:none; width: 6rem;     transform: scale(0.60); "
        >
      </div>


  </div><!-- /col--right -->


</div><!-- /layout -->




<script type="text/javascript" src="/static/js/echarts.min.js"                                    ></script>
<script type="text/javascript" src="/static/js/gradient-legend.js?v={{staticVersion}}"            ></script>
<script type="text/javascript" src="/static/js/eu-and-euro-countries.js?v={{staticVersion}}"      ></script>
<script type="text/javascript" src="/static/dl/ecb-council-by-function.js?v={{staticVersion}}"    ></script>


<!--
  'module'
    runs after  HTML is fully parsed
    runs before DOMContentLoaded fires

    images, fonts not yet being loaded
    layout  sizes not yet available
-->
<script type="module">

  // wrap in async func, since we need `await fetch(...)` at top level
  (async () => {

    const root        = document.documentElement;
    const myChartDom  = document.getElementById('echart_container');
    const currentYear = new Date().getFullYear();

    // xxxxx
    // init
    let selectedDataMeta = {
      "main": {
        "selected_data" : councilByFunction,
        "formatter": (statsValue) => {
          return Math.round(statsValue).toString() + ' %'
        },
        "formatter_legend": (vl) => {
          vl = Math.round(vl).toString();
          if(vl==="0"){
            return "0\nNeutral";
          }
          if(vl==="1"){
            return "1\nHaw- kish";
          }
            if(vl==="-1"){
            return "-1\nDov- ish";
          }
          return vl;
        },

        // yellow - stingy -  blue - flood of liquidity
        "color_ranges": [-1.0, 0.0 , 1.0],
        "colors":       [ "#0000A0","#A0A0A0", "#A0A000"],

        // "color_ranges": [-1.0, -0.75,   0.0 , 0.75, 1.0],
        // "colors":       [ "#0000A0","#0000A0", "#A0A0A0", "#A0A000", "#A0A000"],

      } ,
    };


    const rawHash      = window.location.hash;
    const byUrlHash    = rawHash.slice(1);     // remove leading '#' -  ameco_debt_to_gdp or ""
    if (byUrlHash !== ""){
      selectedVar    = byUrlHash;
    }
    // console.log(` url hash '${byUrlHash}' - selected var ${selectedVar}`);

    const displayType = getComputedStyle(root).getPropertyValue('--display-type').trim();

    const colPri = getComputedStyle(root).getPropertyValue('--color-primary').trim();
    const colSec = getComputedStyle(root).getPropertyValue('--color-secondary').trim();
    const colGr2 = getComputedStyle(root).getPropertyValue('--color-grey-lt').trim();
    const colIB3 = getComputedStyle(root).getPropertyValue('--color-iceblue-3').trim();




    const elOpa = document.getElementById("color_opacity");
    let storedOpacity = localStorage.getItem("initOpacity");
    let initOpacity = 0.6;
    if (storedOpacity !== null) {
        initOpacity = parseFloat(storedOpacity);
        // console.log(`  initOpacity from store ${initOpacity}  `)
    }
    root.style.setProperty("--initOpacity", initOpacity.toString());
    elOpa.value = initOpacity;
    elOpa.addEventListener('change', function (evt) {
      localStorage.setItem("initOpacity", evt.target.value.toString());
      console.log(`selected opacity ${evt.target.value}`);

      createGradientLegend( "gradient1", selectedDataMeta["main"]);

      sliderEl.dispatchEvent(
        new InputEvent('change', {
          bubbles:    true,
          cancelable: true,
        })
      );

    });

    createGradientLegend( "gradient1", selectedDataMeta["main"]);




    function mapToZeroOne(vl, ranges) {

        let range0 = ranges[0];
        let range1 = ranges[1];
        let range2 = ranges[2];

        if (vl <= range1) {
            let t = (vl - range0) / (range1 - range0);
            return Math.max(0, Math.min(1, t));
        } else {
            let t = (vl - range1) / (range2 - range1);
            return Math.max(0, Math.min(1, t));
        }
    }
    function valToPctToColor(vl, config) {

        let opacity = initOpacity;
        if (elOpa){
          opacity = elOpa.value;
          opacity = elOpa.value.toString(16);
          opacity = parseFloat(opacity);
        }
        let tmp = Math.floor(opacity * 255);
        let opacityHex = tmp.toString(16);
        if (opacityHex.length < 2) {
            opacityHex = "0" + opacityHex;
        }

        const gradWrap2 = document.getElementById("gradient1");
        if (gradWrap2) {
          gradWrap2.style.opacity = opacity;
        }


        const ranges = config["color_ranges"]
        const colors = config["colors"]  //     ["#FF0000", "#80A000", "#00A000"]

        function separateVals(hexColor) {
            let cleanHex = hexColor.replace("#", "");
            let componentArray = [];
            for (let idx1 = 0; idx1 < cleanHex.length; idx1 += 2) {
                let hexPair = cleanHex.substring(idx1, idx1 + 2);
                let comp = parseInt(hexPair, 16);
                componentArray.push(comp);
            }
            return componentArray;
        }

        let colorsSeparated = [];
        for (let [idx1, color] of colors.entries()) {
            let rgbComponents = separateVals(color);
            colorsSeparated.push(rgbComponents);
        }

        // const colR0 = [0x00, 0xA0, 0x00]; // mostly green
        // const colR1 = [0x80, 0x80, 0x00]; // yellow
        // const colR2 = [0xff, 0x00, 0x00]; // red

        const colR0 = colorsSeparated[0];
        const colR1 = colorsSeparated[1];
        const colR2 = colorsSeparated[2];


        function interpolate(a, b, t) {
            const out = [0, 0, 0];
            for (let idx1 = 0; idx1 < 3; idx1++) {
                out[idx1] = Math.round(a[idx1] + (b[idx1] - a[idx1]) * t);
            }
            return out;
        }

        let r0 = ranges[0];
        let r1 = ranges[1];
        let r2 = ranges[2];

        let rgb;

        if (vl <= r0) {
            rgb = colR0.slice();
        } else if (vl <= r1) {
            let t = mapToZeroOne(vl, ranges);
            rgb = interpolate(colR0, colR1, t);
        } else if (vl <= r2) {
            let t = mapToZeroOne(vl, ranges);
            rgb = interpolate(colR1, colR2, t);
        } else {
            rgb = colR2.slice();
        }

        const asHex = rgb.map(function (v) {
            const  h = v.toString(16);
            return h.length === 1 ? "0" + h : h;
        });

        return "#" + asHex.join("") + opacityHex;
    }





    const myChart = echarts.init(myChartDom, null, {
      renderer: 'canvas',
      useDirtyRect: false
    });



    function symbolsSeries(){
      let results = [];

      let item1 = {
        name: 'ECB Tower large',
        type: 'scatter',
        coordinateSystem: 'geo',
        symbol: 'circle',
        symbol: 'image:///static/img/ecb/ecb-tower-02.png',
        symbolSize:   [ 3.5*20,  3.5*30],
        symbolSize:   [ 3.5*20,  3.5*22],  // shortened - view from steeply above
        animation:         false,
        animationDuration: 0,
        data: [
            {
                name: 'ECB Tower',
                value: [33.4, 51.2]
            }
        ],
        tooltip: {
            show: false,
            formatter: 'ECB Tower'
        }
      }
      results.push(item1);


      // text-only label at a geo position
      let item2 = {
        name: 'ECB building label',
        type: 'scatter',
        coordinateSystem: 'geo',
        symbol: 'circle',
        symbolSize: 0,
        zlevel: 11,
        label: {
            show: true,
            formatter: 'ECB',
            position: 'inside',   // on the point
            offset: [0, 0],       // fine-tune in px
            color: '#222',
            fontSize: 13,
            backgroundColor: 'rgba(0,0,0,0.5)',
            backgroundColor: 'transparent',
        },
        itemStyle: {
            // opacity: 0               // hide the symbol itself
        },
        data: [
            {
                name: 'ECB building label',
                value: [33.7, 54.0]
            }
        ],
        tooltip: {
            show: false
        }
      }
      results.push(item2);

      return results;
    }


    // creating numbers at the centroid of 27 eu countries
    function manyCountriesShowStats(yr=currentYear) {


      let fontSizeByDisplay = 12;
      if (displayType === "mobile") {
        fontSizeByDisplay = 10;
      }


      let results = [];
      // xxxxx
      for (const rec of councilByFunction) {


        let role1 = rec["organisation_euro"]
        if(role1 === "ecb"){
          continue;
        }

        let country = rec["country"]


        let yearStart = rec["year_start"]
        let yearStop  = rec["year_stop"]
        if (yearStop === 0) {
          yearStop = 9999;
        }
        if(yearStart <= yr  &&  yearStop >= yr){
          // is current
        } else {
          continue;
        }



        let statsValue = rec["hawkish_score"];

        // console.log(` ${country}  ${statsValue} `)
        // console.log(`   coords ${centroids[country][0]}  ${centroids[country][1]}  `)

        let item = {
          type: 'scatter',
          coordinateSystem: 'geo',
          symbol: 'circle',
          symbolSize: 34,
          symbolSize:  0,
          color: valToPctToColor(statsValue, selectedDataMeta["main"]),  // only if symbolSize > 0
          animation:         false,
          animationDuration: 0,
          label: {
            show: true,
            formatter:      Math.round(statsValue*100).toString(),
            fontSize:       14,
            fontSize:       fontSizeByDisplay,
            fontWeight:     300,
            color:         '#000',
            align:         'center',
            verticalAlign: 'middle',
          },
          data: [{ name: 'value', value: [   centroids[country][0], centroids[country][1], statsValue] }],
          tooltip:  { show: true, formatter: `${statsValue}` },
          tooltip:  { show: false },
          z: 10,
        };
        results.push(item);
      }
      return results;
    }






    function extraRectangle(country, offsetX, offsetY){
      // the rectangles around 'Euro area (20 countries)', Cyprus and Malta, not Luxembourg,
      // differing only in offset

      let fontSizeByDisplay = 11;
      let backgroundByDisplay = 'transparent';
      if (displayType === "mobile") {
        fontSizeByDisplay = 10;
        backgroundByDisplay = '#f5f5f5';
      }
      if (displayType === "mobile") {
        offsetY = offsetY + 8;
      }

      let areaCol = 'rgba(217,233,236,0.15)';
      let label   = country;
      if (country === "Euro area (20 countries)"){
        areaCol = 'rgba(217,233,236,1.00)';
        areaCol = 'rgba(244,244,244,1.00)';
        label   = country + "\n + Bulgaria";
        label   = "Entire Euro area";
        label   = "{{i18n.entire_euro_area}}";

        if (displayType === "mobile") {
          offsetX = offsetX + 40;
          offsetY = offsetY - 10;
        }

      }

      const item =
        {
          name: `${country} Inset Rectangle`,
          itemStyle: {
            areaColor:    'none',
            areaColor:   areaCol,
            borderColor:  '#aaa',
            borderWidth: 0.5,   // <â€” thinner border (default is 1)
          },
          emphasis: { disabled: true },
          tooltip:  { show:     false },
          label: {
            show:      true,
            // magnifier optional
            // formatter: text + 'ðŸ”',
            // formatter: 'ðŸ’ ' + text.replace(/\s*\(Inset\)\s*$/i, '')  ,
            formatter:    label,
            formatter:    '{label|' + label + '}',
            fontSize:      fontSizeByDisplay,
            fontWeight:    300,

            // position: 'top-right',  // unsupported
            position: 'top',
            align:    'left',
            offset:    [offsetX, offsetY],

            // rich text for multi line - vertically left
            rich: {
              label: {
                height:           12,
                align:         'left',
                verticalAlign: 'top',
                fontSize:       fontSizeByDisplay,
                fontWeight:    300,


                backgroundColor: backgroundByDisplay,
                borderWidth: 1,              //
                padding: [3, 4, 3, 4],       // top, right, bottom, left
                borderRadius: 3 ,             //



              }
            },
          },
        }
        return item;
    }



    function regionsColoring(yr=currentYear) {

      let results = [];

      for (const [idx, country] of nonMembers.entries()) {
          let item = {
            name:  country,
            tooltip: {
              show:      true,
              formatter: country + "\n(non EU)",
            },
            itemStyle: {
              areaColor:   '#eee',
              borderWidth:  0.4,
              borderColor: '#ccc'
            },
            emphasis: {
              disabled: true,
            },
           };
          // console.log(`  regionsColoring()-1 ${country}`);
          results.push(item);
      };


      for (const [idx, country] of notInEuro.entries()) {
          let item = {
              name: country,
              tooltip: {
                show:      true,
                formatter: country + "\n(no â‚¬)",
              },
              itemStyle: {
                areaColor: 'rgb(238, 245, 245)',
                borderWidth: 0.2,
                aaborderColor: '#ccc',
              },
              emphasis: { disabled: true },
          };
          // console.log(`  regionsColoring()-2 ${country}`);
          results.push(item);
      };


      // xxxxx
      for (const [idx, country] of euCountriesEuro.entries()) {

        const colorNoData = 'rgba(224, 224, 224, 0.28)';
        let areaCol = colorNoData;

        for (const rec of councilByFunction) {
          let role1 = rec["organisation_euro"]
          if(role1 === "ecb"){
            continue;
          }

          let countryX    = rec["country"];
          if(country===countryX){
            let statsValue = rec["hawkish_score"];
            areaCol = 'rgba(199, 199, 244, 0.28)';
            areaCol = valToPctToColor(statsValue, selectedDataMeta["main"])
          }
        }


        let item = {
              name: country,
              tooltip: {
                show:      true,
                formatter: country,
              },
              itemStyle: {
                areaColor:   areaCol,
                borderWidth: 0.2,
                // borderColor: '#444',
              },
          };
          // console.log(`  regionsColoring()-3 ${country}`);
          results.push(item);
      };

      return results;
    }


    function arrowRedraw() {

        return;

        const pixel = myChart.convertToPixel({ geoIndex: 0 }, ecbCoord);

        const containerWidth  = myChartDom.clientWidth;
        const containerHeight = myChartDom.clientHeight;

        let p0x = pixel[0];
        let p0y = pixel[1];
        // tuning arrow below icon
        // p0x = p0x -  8;
        // p0y = p0y + 26;
        p0x = p0x + 2;
        p0y = p0y - 3;

        let endX = containerWidth + 0;
        endX = 630;
        let  endY = p0y;
        endY = 220;

        // const midX = (startX + endX) / 2;
        let p1x = (p0x + endX) / 3.4;
        let p1y =  p0y - 0;

        p1x = 550;
        p1y = 220;


        const pointsForPolyLine = [
            [p0x, p0y],
            [p1x, p1y],
            [endX, endY]
        ];

        myChart.setOption({
            graphic: [
                {
                    id: 'ecb-arrow-line',
                    type: 'polyline',
                    shape: {
                        points: pointsForPolyLine
                    },
                    style: {
                        stroke: '#333',
                        lineWidth: 0.4
                    },
                    silent: true,  // no reaction to click, hover, drag...
                },
                // {
                //     id: 'ecb-arrow-head',
                //     type: 'polygon',
                //     shape: {
                //         points: [
                //             [p0x    , p0y - 12],    // tip
                //             [p0x - 8, p0y +  2],    // left  point
                //             [p0x + 8, p0y +  2]     // right point
                //         ]
                //     },
                //     style: {
                //         fill: '#888'
                //     },
                //     silent: true
                // },
            ]
        });
    }











    //  determine the root path based on current host
    const ROOT_PATH = window.location.origin;
    let url;
    url = ROOT_PATH + '/static/echart/europe-reduced.geojson?v={{staticVersion}}';
    myChart.showLoading();

    let res;
    const isDevMode = window.APP_DEBUG;
    if (isDevMode) {
      // res = await fetch(url, { cache: 'no-cache' });
      res = await fetch(url, { cache: 'no-store' });
      console.log(`fetching map data - since development mode`);
    } else {
      res = await fetch(url, { cache: 'force-cache' });
      console.log(`map data from cache - since production mode`);
    }
    if (!res.ok) { throw new Error(`HTTP ${res.status}`); }
    const geoJSON = await res.json();   // works even if server sends text/plain
    echarts.registerMap('europe-reduced', geoJSON);
    // console.log("europe geo json loaded and registered")

    // prepare longitude/latitude data from geojson file for positioning of geo shapes
    let centroids = {};
    for (let feature of geoJSON.features.entries()) {
      // console.log(feature[1].properties);
      let name = feature[1].properties.name;
      let lon  = feature[1].properties.LON;
      let lat  = feature[1].properties.LAT;
      centroids[name] = [lon, lat];
    }
    // we can now use `centroids` for scatter data, tooltips, etc.
    // console.log(` geo coords for centroid of France ${centroids["France"][0]} ${centroids["France"][1]}`)



    const optionsInit = {

      tooltip: {},
      legend: {
        show: false,
      },

      //
      toolbox: {
        show:   true,
        right: '0.125%',
        top:   '0.125%',

        itemSize: 10,
        itemGap:   6,

        iconStyle: {
          borderColor: '#666',
          borderWidth: 1
        },


        feature: {
          restore: {
            title: 'ðŸ” 100%'
          },
          saveAsImage: {
            type: 'png',          // or 'jpeg', 'svg'
            name: 'ecb-monitor-map-screenshot',
            backgroundColor: '#fff',
            pixelRatio: 2,
          },
        },
      },



      // global colors for series - taken from main-fonts.css
      color: [
        'rgb(194, 211,   0)',
        'rgb( 0,  105, 180)',
        'rgb(245, 245, 246)',
        'rgb(112, 111, 111)',
        'rgb(157, 157, 156)',
        'rgb(174, 215, 217)',
      ],





      geo: {
        map: 'europe-reduced',
        roam: true,

        // zoom out to 300% => 1/3
        // zoom in  to 400% => 4
        scaleLimit: {
          min: 0.75,
          max: 4
        },

        aspectScale: Math.cos((55 * Math.PI) / 180),
        aspectScale: Math.cos((35 * Math.PI) / 180),
        aspectScale: Math.cos((30 * Math.PI) / 180),  // vertical compression of map projection

        // projection: {
        //     project: function (point) {
        //         return [point[0], Math.log(Math.tan((Math.PI / 4) + (point[1] * Math.PI / 360)))];
        //     },
        //     unproject: function (point) {
        //         return [point[0], (2 * Math.atan(Math.exp(point[1])) - Math.PI / 2) * 180 / Math.PI];
        //     }
        // },

        // zoom: 0.75,

        // top:    -240,     // margin top
        // bottom: -130,
        // left:   0,
        // right:  0,

        center:       [ 16     ,  48.8  ],  // geo center - longitute - latitude
        center:       [ 13.0   ,  48.8  ],
        layoutCenter: ['50%', '50%'],    // where to place the geo center
        // layoutSize:    '250%',



        boundingCoords: [
            // [minLon, minLat],
            //  north of finland -  west of ireland
                [16 - 9.2         , 48.5 - 11.6],
            // [maxLon, maxLat],
                [16 + 9.2 - 0.2   , 48.5 + 11.6],
        ],

        // universalTransition: true,

        // on hover
        //  only global setting possible
        emphasis: {
          itemStyle: {
            // areaColor:    'transparent',
            areaColor:    colPri,
            areaColor:   'inherit',
            borderWidth:  0.8,
            borderWidth:  1.3,
            borderColor: '#444',
          },
          label: { show: false }
        },


        nameProperty: 'name', //  name_en - for using en name.
        itemStyle: {
          // https://echarts.apache.org/en/option.html#legend.itemStyle
          areaColor:            colIB3,
          areaColor:           'transparent',  // no default color - everything in regionsColoring()
          borderColor:         '#999999',
          inactiveColor:       '#f11',
          inactiveBorderColor: '#ccc',
          borderWidth:           0.50,
        },


        regions: [
          // changing properties of existing shape (by name)
          ...regionsColoring(),                // returns list of items
          //  drawing additional shapes
          extraRectangle('Cyprus', -14,-37),
          extraRectangle('Malta' ,  -6,-26),
          extraRectangle('Euro area (20 countries)', -45,-51),
        ],

      },   // end geo


      series: [
        // adding chart elements
        // gre-enwich  longitude, latitude
        ...manyCountriesShowStats(),         // returns list of items
        ...symbolsSeries(),                  // returns list of items
      ]

    };


    myChart.hideLoading();
    myChart.setOption(optionsInit);
    arrowRedraw();


    window.addEventListener('resize', function() {
        myChart.resize();
        arrowRedraw();
    });

    myChart.on('georoam', function() {
        arrowRedraw();
    });



    // --- slider setup: 1960 .. (current year + 1) ---
    const sliderEl = document.getElementById('yearSlider');
    const labelEl  = document.getElementById('yearLabel');

    sliderEl.max        = String(currentYear+0);
    sliderEl.value      = String(currentYear);
    labelEl.textContent = sliderEl.value;

    function sliderToKey(){
      const yr = parseInt(sliderEl.value, 10);
      return {
        yr: yr,
        lbl:String(yr),
      };
    }

    sliderEl.addEventListener("wheel", function(evt) {
        evt.preventDefault();               // stop page scrolling
        const direction = Math.sign(evt.deltaY);
        let newValue = Number(sliderEl.value) - direction * wheelStep;

        if (newValue < sliderEl.min) {
            newValue = sliderEl.min;
        }
        if (newValue > sliderEl.max) {
            newValue = sliderEl.max;
        }
        sliderEl.value = newValue;
        sliderEl.dispatchEvent(new Event("input"));    // trigger input event
    });




    function buildMemberCard(member) {

      const keysDisplay = [
        "name",
        "role_euro__from_to",
        // "role_euro",
        // "from_to",

        // "born_raised",
        // "career",

        "hawkish_score",
        // "count_speeches",
      ];

      const popupKeys = [
        "born_raised",
        "education",
        "career",
      ];


      const outerDiv = document.createElement("div");
      outerDiv.className = "member-card";


      for (let idx1 = 0; idx1 < keysDisplay.length; idx1 += 1) {

        const ky = keysDisplay[idx1];
        let   vl = member[ky];

        if(ky === "hawkish_score"){
          if (Number.isFinite(vl)) {
            vl = vl.toFixed(2)
          } else {
            vl = "0.00"
            vl = "- \u00A0\u00A0" // non breaking space
          }
        }

        if(ky === "role_euro__from_to"){
          vl = vl.replace("since",          "{{i18n.since}}")  ;
          vl = vl.replace("vice-president", "{{i18n.vice_president}}")  ;
          vl = vl.replace("president",      "{{i18n.president}}")  ;
          vl = vl.replace("chief economist, ", "")  ;
          vl = vl.replace("executive board, ", "")  ;
        }

        const rowDiv = document.createElement("div");
        rowDiv.className   = ky;

        if (vl === null || typeof vl === "undefined") {
          rowDiv.textContent = `${ky}: -`;
        } else {
          // rowDiv.textContent = `${myKey}: ${String(myVal)}`;
          rowDiv.textContent = `${String(vl)}`;
        }


        if(ky === "hawkish_score"){
          let vl2 = member[ky];
          const bgCol = valToPctToColor(vl2, selectedDataMeta["main"]  );
          rowDiv.style.backgroundColor = bgCol;
        }


        outerDiv.appendChild(rowDiv);
      }


      let titleMouseOver = ""
      for (let idx1 = 0; idx1 < popupKeys.length; idx1 += 1) {
        const ky = popupKeys[idx1];
        let   vl = member[ky];



        if (vl === null || typeof vl === "undefined") {
          //
        } else {
          vl = vl.replace("education",    "{{i18n.education}}")  ;
          vl = vl.replace("experience",   "{{i18n.experience}}")  ;
          titleMouseOver += `${vl} \n`;
        }
      }
      outerDiv.setAttribute("title", titleMouseOver)

      return outerDiv;
    }


    function populateLeftPanel(yr=currentYear) {

      const councilList = document.getElementById("council_list");
      councilList.replaceChildren(); // reset

      let namesSorted = Object.keys(councilByFunction);  // sorting is done in python pre-processing
      namesSorted.forEach(function (name) {

        const rec = councilByFunction[name];

        let role1 = rec["organisation_euro"]
        if(role1 !== "ecb"){
          return;
        }

        let yearStart = rec["year_start"]
        let yearStop  = rec["year_stop"]
        if (yearStop === 0) {
          yearStop = 9999;
        }

        // console.log(   `${yearStart} < ${currentYear}  <   ${yearStop}` )
        if(yearStart <= yr  &&  yearStop >= yr){
          // is current
        } else {
          return;
        }

        const card = buildMemberCard(rec);
        councilList.appendChild(card);

      });  // end of foreach

    }




    // --- onChange handler: update the chart option (stub) ---
    sliderEl.addEventListener('change', function () {

      const res = sliderToKey();
      labelEl.textContent = res.lbl;

      populateLeftPanel(res.yr)

      // mutate option and re-apply
      let option3;

      // reset the stuff we want to update
      option3 = {
        series: [],
        geo: {
          regions: [],
        },
      };
      // re-populate
      option3.series = [
        ...manyCountriesShowStats(res.yr),
        ...symbolsSeries(),
      ];
      option3.geo.regions  = [
          ...regionsColoring(res.yr),
          extraRectangle('Cyprus', -14,-37),
          extraRectangle('Malta' ,  -6,-26),
          extraRectangle('Euro area (20 countries)', -45,-51),
      ];

      console.log(` changing year to ${res.yr} `);
      myChart.setOption(
        option3,
        {
          notMerge :   false,  // do merge
          lazyUpdate : true,
        },
      );

    });



    sliderEl.dispatchEvent(
      new InputEvent('change', {
        bubbles:    true,
        cancelable: true,
      })
    );


  })();   // end of outmost aync func - so we can you fetch inside




</script>




