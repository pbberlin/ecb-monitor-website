<style>

  :root{
    --grad-height:   1.2rem;
    --w01:           max(20rem, 20vw);  /* width left and right column  */
    --echartHeight:   75vh;              /* not 75% -  fails */  
    --marginHeight:  calc( var(--echartHeight) - 1rem);
    --initOpacity:   0.6;               /* minimize flickering */
  }


  /* radio buttons 20% larger */
  input[type="radio"] {
    transform:         scale(1.34);
    -webkit-transform: scale(1.34);    /* Safari / older WebKit */
    -ms-transform:     scale(1.34);    /* old IE/Edge */
    transform-origin:  center;
    vertical-align:    middle;

    position: relative;
    top: -0.12rem;

  }



  html,
  body,
  dummy {
    height: 100%;
  }


  /*
    container: left-to-right flow, top-aligned
    3 columns
    - col 1: 20% - at least 20vm
    - col 2: exactly 820px
    - col 3: 1fr - takes remaining width
    -           or right margin max(20rem, 20vw)
  */
  .layout {
    width: calc( 820px + 2* var(--w01));
    margin: 0 auto;

    display: grid;
    grid-template-columns:  var(--w01) 820px  var(--w01);
    column-gap: 0;
    align-items: start;           /* vertical: top for all */

    /* border: 1px solid red; */
  }

  /* Ensure grid items can shrink if needed */
  .col {
    min-width: 0;
    padding:   0;
    margin:    0;
    /* margin: 2px; */
    /* border: 1px solid red; */
  }


  /* col1 - at least 20rem - 20% of screen width - */
  .col--left   {
    height: var(--marginHeight);
    min-width: calc( var(--w01) - 0.5rem );

    justify-self: end;
    align-self: start;
    text-align: right;
    /* width: max-content; */
  }

  /* col2 -  fixed 820px, content centered */
  .col--center {
    justify-self: center;
    align-self: start;
  }

  /* col3 - takes the residual space, content left */
  .col--right  {
    height: var(--marginHeight);
    min-width: calc( var(--w01) - 0.5rem );
    /* width: max-content; */


    justify-self: start;
    align-self:   start;
    text-align:   left;
  }



  #echart_container {

    /* not 100% -  fails */
    width: 820px;

    height: var(--echartHeight);

    /* margin:  0 auto; */
    padding: 0;
    border-bottom: 1px solid lightgray;
    /* border-right:  1px solid lightgray; */
    /* border: 1px solid lightgray; */
    box-sizing: border-box;
  }





  .control-pad {
    position: relative;   /*  z-index  */
    z-index: 10;
    margin: 0.4rem;
    border-radius: 0.2rem;
    padding: 0.5rem 1.1rem;
    background-color: rgba(217,233,236,0.25)
  }

  #slider-group {
    display:        flex;
    flex-direction: column;
    gap: 0.01rem;
    align-items: center;   /* contents centered horizontally */
    height:      auto;
    width:       max-content;    /* shrink container to content so it can sit right */

    margin-top:    1.1rem;
    margin-bottom: 1.1rem;
    margin-left: auto;
  }

  .options-stat-vars {
    display:        flex;
    flex-direction: column;   /* vertical arrangement */
    align-items: flex-end;    /* right  alignment */
    gap: 0.5rem;              /* vertical spacing */
  }




  #bullet-container li {
    list-style-type: circle;
    margin: 1rem;
  }




</style>



<div class="layout">

  <div class="col col--left control-pad">

      <!--
      {{i18n["good_day"]}}
      {{i18n.good_day}}
      -->

      <!-- First (top, right) -->
      <h3 > {{i18n.headline_fiscal_data}}</h3>

      <!-- <label for="yearSlider">Year:</label> -->
      <div id="slider-group">
        <input id="yearSlider" type="range" min="2000" step="1"  autofocus />
        <span id="yearLabel"></span>
      </div>

      <!-- option -->
      <div class="options-stat-vars">
        <label title="(Ameco)">
          Ã–ffentliche Schulden in % BIP
          <input type="radio" name="stats_variable" value="ameco_debt_to_gdp" >
        </label>

        <label title="(Ameco)">
          Nettokreditaufnahme % BIP
          <input type="radio" name="stats_variable" value="ameco_net_lending">
        </label>


        <label title="(Ameco)">
          Staatsquote % BIP
          <input type="radio" name="stats_variable" value="ameco_total_expenditure">
        </label>


        <label title="(Ameco)">
          Zinszahlungen in % Staatsausgaben
          <input type="radio" name="stats_variable" value="ameco_interest_expenditure">
        </label>

        <!--
        <label title="(Ameco)">
          Zinszahlungen in % BIP
          <input type="radio" name="stats_variable" value="ameco_interest_to_gdp">
        </label>
        -->

        <label title="(Eurostat)">
          ZehnjÃ¤hrige Staatsanleihen
          <input type="radio" name="stats_variable" value="eurostat_yields_10y">
        </label>


      </div>


      <div class="slider-group" style="margin:1.2rem;margin-right:0.4rem">
        <a id="linkPlay" href="#" title="2000 till present">>> Play</a>
      </div>

      <div class="slider-group" style="margin:1.2rem;margin-right:0.4rem">
        <a id="linkDownload" href="#" title="European CSV, semikolon delimited, decimal separator: comma, UTF-8" download>Daten herunterladen</a>
      </div>



  </div>


  <div class="col col--center">
    <div id="echart_container">echart container content</div>
  </div>



  <div class="col col--right control-pad" astyle="height: 90%;">



      <style>

        .gradientWrapper1 {
            position:    relative;
            height:      var(--grad-height);
            width:       100%;
            margin:      2rem 0;
            /* margin-top:  0; */
            /* border: 1px solid gray; */
        }

        .myGradient1 {
            height:   var(--grad-height);
            width:    100%;
            opacity:  var(--initOpacity);
            background: linear-gradient(
                to right,
                #00A000   0%,
                #A08000  30%,
                #A08000  30%,
                #FF0000  90%,
                #FF0000 100%
            );
            /* border: 1px solid #444; */
        }

        .myGradient2 {
            height:   var(--grad-height);
            width:    100%;
            opacity:  var(--initOpacity);

            /* background is set dynamically by JS */
        }


        .tick {
            position: absolute;

            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 0.4rem;

            height:  5px;
            width:   1px;
            top:     calc(var(--grad-height) + 0.0rem);

            background: black;
            text-align:   center;
            transform:    translateX(calc(-50% + 1px));
            font-size: 11px;
        }
        .tick:last-child {
            transform:    translateX(calc(-50% - 1px));
        }

      </style>


      <!-- 
      <div class="gradientWrapper1">
          <div class="myGradient1" id="myGradient1"></div>
          <div class="tick" style="left:   0px;">  0%</div>
          <div class="tick" style="left:   30%;"> 60%</div>
          <div class="tick" style="left:   50%;">100%</div>
          <div class="tick" style="left:  100%;">180%</div>
      </div>
      -->


      <div class="slider-group"
          style="margin-top: 4.5rem;"
          title="change  saturation / opacity of the map colors"
      >
        <span style="font-size: 65%; font-weight: 300; display: inline-block; position: relative; top: -5px;"
        >{{i18n.color_saturation}} </span>
        <input name="color_opacity" id="color_opacity" type="range" min="0" max="1" step="0.1" 
          value="0.6"
          style="border:none; width: 4rem;"
        >

      </div>








  <div class="gradientWrapper1">
      <div class="myGradient2" id="myGradient2"></div>
  </div>










    <ul id="bullet-container" >
    </ul>

  </div>


</div>






<!-- <script type="text/javascript" src="https://fastly.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script> -->
<script type="text/javascript" src="/static/js/echarts.min.js"></script>
<script type="text/javascript" src="/static/js/eu-and-euro-countries.js"></script>
<script src="/static/dl/ameco_debt_to_gdp.js"          ></script>
<script src="/static/dl/ameco_net_lending.js"          ></script>
<script src="/static/dl/ameco_total_expenditure.js"    ></script>
<script src="/static/dl/ameco_interest_expenditure.js" ></script>
<script src="/static/dl/ameco_interest_to_gdp.js"      ></script>
<script src="/static/dl/eurostat_yields_10y.js"        ></script>


<!-- Uncomment this line if you want to dataTool extension -->
<!-- <script type="text/javascript" src="https://fastly.jsdelivr.net/npm/echarts@6/dist/extension/dataTool.min.js"></script> -->

<!-- Uncomment this line if you want to use gl extension -->
<!-- <script type="text/javascript"  src="https://echarts.apache.org/en/js/vendors/echarts-gl/dist/echarts-gl.min.js"></script> -->

<!-- Uncomment this line if you want to echarts-stat extension -->
<!-- <script type="text/javascript" src="https://echarts.apache.org/en/js/vendors/echarts-stat/dist/ecStat.min.js"></script> -->

<!-- Uncomment this line if you want to echarts-graph-modularity extension -->
<!-- <script type="text/javascript" src="https://echarts.apache.org/en/js/vendors/echarts-graph-modularity/dist/echarts-graph-modularity.min.js"></script> -->


<!-- Uncomment this line if you want to use map -->
<!-- <script type="text/javascript" src="https://fastly.jsdelivr.net/npm/echarts@4.9.0/map/js/world.js"></script> -->


<!-- Uncomment these two lines if you want to use bmap extension -->
<!-- <script type="text/javascript" src="https://api.map.baidu.com/api?v=3.0&ak=YOUR_API_KEY"></script> -->
<!-- <script type="text/javascript" src="https://fastly.jsdelivr.net/npm/echarts@6/dist/extension/bmap.min.js"></script> -->

<!-- <script type="text/javascript"> -->

<script type="module">

  // wrap everything in an async func, since we need `await fetch(...)` at top level
  (async () => {

    const myChartDom  = document.getElementById('echart_container');
    const currentYear = new Date().getFullYear();
    const elOpa = document.getElementById("color_opacity");


    // xxxxx
    let selectedDataMeta = {
      "ameco_debt_to_gdp": {
        "selected_data" : debtPercentToGDP,
        "formatter": (statsValue) => {
          return Math.round(statsValue).toString() + ' %'
        },
        "color_ranges": [0, 60, 180, 200],
        "colors":       ["#00A000", "#80A000", "#FF0000", "#FF0000"],
      } ,
      "ameco_net_lending": {
        "selected_data" : netLendingPercentToGDP,
        "formatter": (statsValue) => {
          return  (Math.round(statsValue*10)/10).toString() + ' %'
        },
        "color_ranges":  [-2, 3, 6],
        "colors":        ["#00A000", "#80A000", "#FF0000"]
      } ,
      "ameco_total_expenditure": {
        "selected_data" : totalExpenditure,
        "formatter": (statsValue) => {
          return Math.round(statsValue).toString() + ' %'
        },
        "color_ranges": [ 1,  30, 60, ],
        "colors":        ["#00A000", "#80A000", "#FF0000"]
      } ,
      "ameco_interest_expenditure": {
        "selected_data" : interestExpenditure,
        "formatter": (statsValue) => {
          return  (Math.round(statsValue*10)/10).toString() + ' %'
        },
        "color_ranges": [ 1,  3, 6, ],
        "colors":        ["#00A000", "#80A000", "#FF0000"]
      } ,
      "ameco_interest_to_gdp": {
        "selected_data" : interestToGDP,
        "formatter": (statsValue) => {
          return  (Math.round(statsValue*10)/10).toString() + ' %'
        },
        "color_ranges": [ 1,  5, 12, ],
        "colors":        ["#00A000", "#80A000", "#FF0000"]
      } ,
      "eurostat_yields_10y": {
        "selected_data" : yieldsTenYears,
        "formatter": (statsValue) => {
          return  (Math.round(statsValue*10)/10).toString() + ' %'
        },
        "color_ranges": [ 1,  2.5, 5, ],
        "colors":        ["#00A000", "#80A000", "#FF0000"]
      } ,
    };


    // init
    let   selectedVar  = "ameco_debt_to_gdp";
    const rawHash      = window.location.hash;
    const byUrlHash    = rawHash.slice(1);     // remove leading '#' -  ameco_debt_to_gdp or ""
    if (byUrlHash !== ""){
      selectedVar    = byUrlHash;
    }
    // console.log(` url hash '${byUrlHash}' - selected var ${selectedVar}`);

    createGradientLegend( "myGradient2", selectedDataMeta[selectedVar]);


    let statRadios = document.querySelectorAll('input[name="stats_variable"]');
    statRadios.forEach(function(radio) {
        if (radio.value === selectedVar) {
            radio.checked = true;
        }
    });

    const linkDownload = document.getElementById("linkDownload")
    linkDownload.setAttribute("href", `/static/dl/${selectedVar}.csv`)

    const myChart = echarts.init(myChartDom, null, {
      renderer: 'canvas',
      useDirtyRect: false
    });


    const root = document.documentElement;
    const colPri = getComputedStyle(root).getPropertyValue('--color-primary').trim();
    const colSec = getComputedStyle(root).getPropertyValue('--color-secondary').trim();
    const colGr2 = getComputedStyle(root).getPropertyValue('--color-grey-lt').trim();
    const colIB3 = getComputedStyle(root).getPropertyValue('--color-iceblue-3').trim();

    let storedOpacity = localStorage.getItem("initOpacity");    
    let initOpacity = 0.6;
    if (storedOpacity !== null) {
        initOpacity = parseFloat(storedOpacity);
        // console.log(`  initOpacity from store ${initOpacity}  `)
    }    
    root.style.setProperty("--initOpacity", initOpacity.toString());    
    elOpa.value = initOpacity;


    // creating the 'series' config for a pie chart with three random number.
    // Pie charts are easily positioned using either geo coordinates
    // or geojson 'name' -  via line  `center: centerLabelOrCoords`.
    // Other charts types dont have this feature - thus we have to
    //   pull the centroids for countries out of the geojson
    //     centroids['France']
    //     centroids['Spain']
    //     centroids[country][0], centroids[country][1]
    //      [2.21, 46.23]
    // The centroids have been finetuned in reshape-country.py
    function randomPieSeries1(centerLabelOrCoords, radius) {

      const data = ['A', 'B', 'C', 'D'].map((t) => {
        return {
          value: Math.round(Math.random() * 100),
          name: 'Category ' + t
        };
      });

      // map
      return {
        type: 'pie',
        coordinateSystem: 'geo',
        tooltip: {
          formatter: '{b}: {c} ({d}%)'
        },
        label: {
          show: false
        },
        labelLine: {
          show: false
        },
        animationDuration: 0,
        radius: radius,
        center: centerLabelOrCoords,
        data: data,
      };
    }


    // pctToColor(vl, ranges)
    // ranges: [r1, r2]  => 0â†’r1, r1â†’r2, r2â†’max
    function pctToColor(vl, ranges=[1, 60, 180]) {

        let opacity = initOpacity;
        if (elOpa){
          opacity = elOpa.value;
          opacity = elOpa.value.toString(16);
          opacity = parseFloat(opacity);
        }
        let tmp = Math.floor(opacity * 255);
        let opacityHex = tmp.toString(16);
        if (opacityHex.length < 2) {
            opacityHex = "0" + opacityHex;
        }

        const gradWrap1 = document.getElementById("myGradient1");
        if (gradWrap1) {
          gradWrap1.style.opacity = opacity;
        }
        const gradWrap2 = document.getElementById("myGradient2");
        gradWrap2.style.opacity = opacity;


        vl = vl * ranges[0];
        // console.log(`color ${pct} - ${ranges} `);

        if (vl <= 0) {
          // xxxxx 
          vl = 1;
          // return "#00ff00" + opacityHex;
        }
        if (vl >= 300) {
            vl = 300;
        }

        const colGr = [0x00, 0xA0, 0x00];
        const colYl = [0x80, 0x80, 0x00];
        const colRd = [0xff, 0x00, 0x00];

        function interp(a, b, t) {
            const out = [0, 0, 0];
            for (let idx1 = 0; idx1 < 3; idx1++) {
                out[idx1] = Math.round(a[idx1] + (b[idx1] - a[idx1]) * t);
            }
            return out;
        }

        const r1 = ranges[1];
        const r2 = ranges[2];

        let rgb;

        if (vl <= r1) {
            const t = vl / r1;
            rgb = interp(colGr, colYl, t);
        } else if (vl <= r2) {
            const t = (vl - r1) / (r2 - r1);
            rgb = interp(colYl, colRd, t);
        } else {
            rgb = colRd.slice();
        }

        const hex = rgb.map(function (v) {
            const h = v.toString(16);
            return h.length === 1 ? "0" + h : h;
        });
        return "#" + hex.join("") + opacityHex;
    }

    const ecbCoord = [8.6889, 50.1095];  // frankfurt
    // const ecbCoord = [9.851, 51.11];  // germany centroid

    function symbolsSeries(){
      let results = [];

      let item1 = {
        name: 'ECB Tower',
        type: 'scatter',
        coordinateSystem: 'geo',
        symbol: 'circle',
        symbol: 'image:///static/img/ecb/ecb-tower-02.png',
        symbolSize:   [ 1.5*20,  1.5*30],
        symbolSize:   [ 1.5*20,  1.5*22],  // shortened - view from steeply above
        symbolOffset: [ -9,   1],
        symbolOffset: [ -9,  -2],  // second vertical
        animationDuration: 0,
        data: [
            {
                name: 'ECB Tower',
                value: ecbCoord
            }
        ],
        tooltip: {
            show: true,
            formatter: 'ECB Tower'
        }
      }
      results.push(item1);


      let item2 = {
        name: 'ECB Tower large',
        type: 'scatter',
        coordinateSystem: 'geo',
        symbol: 'circle',
        symbol: 'image:///static/img/ecb/ecb-tower-02.png',
        symbolSize:   [ 3.5*20,  3.5*30],
        symbolSize:   [ 3.5*20,  3.5*22],  // shortened - view from steeply above
        animationDuration: 0,
        data: [
            {
                name: 'ECB Tower',
                value: [33.4, 51.2]
            }
        ],
        tooltip: {
            show: false,
            formatter: 'ECB Tower'
        }
      }
      results.push(item2);


      // text-only label at a geo position
      let item3 = {
        name: 'Euro area Label',
        type: 'scatter',
        coordinateSystem: 'geo',
        symbol: 'circle',
        symbolSize: 0,
        zlevel: 11,
        label: {
            show: true,
            formatter: 'Euro area\n(19 countries) and Bulgaria',
            position: 'inside',   // on the point
            offset: [0, 0],       // fine-tune in px
            color: '#222',
            fontSize: 13,
            backgroundColor: 'rgba(0,0,0,0.5)',
            backgroundColor: 'transparent',
            // padding: [3, 5],
            // borderRadius: 3,
        },
        itemStyle: {
            // opacity: 0               // hide the symbol itself
        },
        data: [
            {
                name: 'ECB Tower Label',
                value: [33.7, 54.0]
            }
        ],
        tooltip: {
            show: false
        }
      }

      results.push(item3);

      return results;
    }




    function arrowRedraw() {

        const pixel = myChart.convertToPixel({ geoIndex: 0 }, ecbCoord);

        const containerWidth  = myChartDom.clientWidth;
        const containerHeight = myChartDom.clientHeight;

        let p0x = pixel[0];
        let p0y = pixel[1];
        // tuning arrow below icon
        // p0x = p0x -  8;
        // p0y = p0y + 26;
        p0x = p0x + 2;
        p0y = p0y - 3;

        let endX = containerWidth + 0;
        endX = 630;
        let  endY = p0y;
        endY = 220;

        // const midX = (startX + endX) / 2;
        let p1x = (p0x + endX) / 3.4;
        let p1y =  p0y - 0;

        p1x = 550;
        p1y = 220;


        const pointsForPolyLine = [
            [p0x, p0y],
            [p1x, p1y],
            [endX, endY]
        ];

        myChart.setOption({
            graphic: [
                {
                    id: 'ecb-arrow-line',
                    type: 'polyline',
                    shape: {
                        points: pointsForPolyLine
                    },
                    style: {
                        stroke: '#333',
                        lineWidth: 0.4
                    },
                    silent: true,  // no reaction to click, hover, drag...
                },
                // {
                //     id: 'ecb-arrow-head',
                //     type: 'polygon',
                //     shape: {
                //         points: [
                //             [p0x    , p0y - 12],    // tip
                //             [p0x - 8, p0y +  2],    // left  point
                //             [p0x + 8, p0y +  2]     // right point
                //         ]
                //     },
                //     style: {
                //         fill: '#888'
                //     },
                //     silent: true
                // },
            ]
        });
    }




    function regionsColoring(yr=currentYear) {

      let results = [];

      for (const [idx, country] of nonMembers.entries()) {
          let item = {
            name:  country,
            tooltip: {
              show:      true,
              formatter: country + "\n(non EU)",
            },
            itemStyle: {
              areaColor:   '#eee',
              borderWidth:  0.4,
              borderColor: '#ccc'
            },
            emphasis: {
              disabled: true,
            },
           };
          // console.log(`  regionsColoring()-1 ${country}`);
          results.push(item);
      };

      /*
        rgb(194, 225, 226)
        rgb(214, 235, 236)
        rgb(235, 245, 246)
        rgb(255, 255, 255)
      */
      for (const [idx, country] of notInEuro.entries()) {
          let item = {
              name: country,
              tooltip: {
                show:      true,
                formatter: country + "\n(no â‚¬)",
              },
              itemStyle: {
                areaColor: 'rgb(238, 245, 245)',
                borderWidth: 0.2,
                aaborderColor: '#ccc',
              },
              emphasis: { disabled: true },
          };
          // console.log(`  regionsColoring()-2 ${country}`);
          results.push(item);
      };



      for (const [idx, country] of euCountriesEuro.entries()) {
          try {
             const statsValue    = selectedDataMeta[selectedVar]["selected_data"][yr][country];
             const statsColoring = pctToColor(statsValue, selectedDataMeta[selectedVar]["color_ranges"]  );
            // let item = { name: country, itemStyle: { areaColor: 'rgb(194, 225, 227)', borderColor: '#ccc' } };
            let item = { name: country, itemStyle: { areaColor: statsColoring,} };
            // x14x14
            results.push(item);
            // console.log(`  regionsColoring()-3 ${country} - ${statsValue}`);
          } catch (error) {
            console.log(`no stats value for ${country} for ${yr}`)
          }
      };

      // for (const [idx, country] of notInEuro.entries()) {
      return results;
    }


    function extraRectangle(country, offsetX, offsetY){
      // the rectangles around Cyprus and Malta, not Luxembourg,
      // differing only in offset
      const item =
        {
          name: `${country} Inset Rectangle`,
          itemStyle: {
            areaColor:   'none',
            areaColor:   'rgba(217,233,236,0.15)',
            borderColor: '#aaa',
            borderWidth: 0.5,   // <â€” thinner border (default is 1)
          },
          emphasis: { disabled: true },
          tooltip:  { show:     false },
          label: {
            show:      true,
            // magnifier optional
            // formatter: text + 'ðŸ”',
            // formatter: 'ðŸ’ ' + text.replace(/\s*\(Inset\)\s*$/i, '')  ,
            formatter: country,
            fontSize:       11,
            fontWeight:    300,

            // position: 'top-right',  // unsupported
            position: 'top',
            align:    'left',
            offset:    [offsetX, offsetY],
          },
        }
        return item;
    }



    // creating debt numbers at the centroid of 27 eu countries
    function manyCountriesShowStats(yr=currentYear) {
      let results = [];
      for (let country in selectedDataMeta[selectedVar]["selected_data"][yr]) {
        const statsValue = selectedDataMeta[selectedVar]["selected_data"][yr][country];
        // console.log(country, numberValue);
        let item = {
          type: 'scatter',
          coordinateSystem: 'geo',
          symbol: 'circle',
          // x14x14
          symbolSize: 34,
          symbolSize:  0,
          // symbolOffset: [10, -15],   // moves symbol and label
          color: pctToColor(statsValue, selectedDataMeta[selectedVar]["color_ranges"]),  // only if symbolSize > 0
          animationDuration: 0,
          label: {
            show: true,
            formatter:  Math.round(statsValue).toString() + ' %',
            formatter:  selectedDataMeta[selectedVar]["formatter"](statsValue),
            fontSize:    14,
            fontSize:    12,
            fontWeight: 300,
            color: '#000',
            align: 'center',
            verticalAlign: 'middle',
            // offset:    [32, 0],
            // offset:    [0, 12],
          },
          data: [{ name: 'value', value: [   centroids[country][0], centroids[country][1], statsValue] }],
          tooltip:  { show: true, formatter: `${statsValue}` },
          tooltip:  { show: false },
          z: 10,
        };
        results.push(item);
      }
      return results;
    }






    //  determine the root path based on current host
    const ROOT_PATH = window.location.origin;
    let url;
    url = ROOT_PATH + '/static/echart/usa.json';
    url = ROOT_PATH + '/static/echart/europe-complete.geojson';
    url = ROOT_PATH + '/static/echart/europe-reduced-orig.geojson';
    url = ROOT_PATH + '/static/echart/europe-reduced.geojson';

    myChart.showLoading();

    let res;
    const isDevMode = window.APP_DEBUG;
    if (isDevMode) {
      // res = await fetch(url, { cache: 'no-cache' });
      res = await fetch(url, { cache: 'no-store' });
      console.log(`fetching map data - since development mode`);
    } else {
      res = await fetch(url, { cache: 'force-cache' });
      console.log(`map data from cache - since production mode`);
    }
    if (!res.ok) { throw new Error(`HTTP ${res.status}`); }
    const geoJSON = await res.json();   // works even if server sends text/plain
    echarts.registerMap('europe-reduced', geoJSON);
    // console.log("europe geo json loaded and registered")

    // prepare longitude/latitude data from geojson file for positioning of geo shapes
    let centroids = {};
    for (let feature of geoJSON.features.entries()) {
      // console.log(feature[1].properties);
      let name = feature[1].properties.name;
      let lon  = feature[1].properties.LON;
      let lat  = feature[1].properties.LAT;
      centroids[name] = [lon, lat];
    }
    // we can now use `centroids` for scatter data, tooltips, etc.
    // console.log(` geo coords for centroid of France ${centroids["France"][0]} ${centroids["France"][1]}`)



    const optionsInit = {

      tooltip: {},
      legend: {
        show: false,
      },

      // global colors for series - taken from main-fonts.css
      color: [
        'rgb(194, 211,   0)',
        'rgb( 0,  105, 180)',
        'rgb(245, 245, 246)',
        'rgb(112, 111, 111)',
        'rgb(157, 157, 156)',
        'rgb(174, 215, 217)',
      ],


      geo: {
        map: 'europe-reduced',
        roam: true,
        aspectScale: Math.cos((55 * Math.PI) / 180),
        aspectScale: Math.cos((35 * Math.PI) / 180),
        aspectScale: Math.cos((30 * Math.PI) / 180),  // vertical compression of map projection

        // projection: {
        //     project: function (point) {
        //         return [point[0], Math.log(Math.tan((Math.PI / 4) + (point[1] * Math.PI / 360)))];
        //     },
        //     unproject: function (point) {
        //         return [point[0], (2 * Math.atan(Math.exp(point[1])) - Math.PI / 2) * 180 / Math.PI];
        //     }
        // },

        // zoom: 0.75,

        // top:    -240,     // margin top
        // bottom: -130,
        // left:   0,
        // right:  0,

        center:       [ 16     ,  48.8  ],  // geo center - longitute - latitude
        center:       [ 12.05  ,  48.8  ],
        center:       [ 14.50  ,  48.8  ],  // move ireland as far left as possible
        layoutCenter: ['50%', '50%'],    // where to place the geo center
        // layoutSize:    '250%',


        boundingCoords: [
            // [minLon, minLat],
            //  north of finland -  west of ireland
                [16 - 9.2         , 48.5 - 11.6],
            // [maxLon, maxLat],
                [16 + 9.2 - 0.2   , 48.5 + 11.6],
        ],

        nameProperty: 'name', //  name_en - for using en name.
        itemStyle: {
          // https://echarts.apache.org/en/option.html#legend.itemStyle
          areaColor:            colIB3,
          areaColor:           'transparent',  // no default color - everything in regionsColoring()
          borderColor:         '#999999',
          inactiveColor:       '#f11',
          inactiveBorderColor: '#ccc',
          borderWidth:           0.50,
        },

        // extra colors for eu non-members
        regions: [
          ...regionsColoring(),
          extraRectangle('Cyprus', -14,-34),
          extraRectangle('Malta' ,  -6,-24),
          // rectangles('Luxembourg' ,  0,0),
        ],

        // only global setting possible
        emphasis: {
          itemStyle: {
            // color on hover
            // areaColor:    'transparent',
            areaColor:    colPri,
            borderWidth:  0.8,
            borderColor: '#444',
          },
          label: { show: false }
        },

      },   // end geo



      series: [
        // gre-enwich  longitude, latitude
        // randomPieSeries1([-1.6, 52.5], 25),

        // randomPieSeries1('France',  25),
        // randomPieSeries1('Germany', 35),
        ...manyCountriesShowStats(),
        ...symbolsSeries(),
      ]

    };

    myChart.hideLoading();
    myChart.setOption(optionsInit);
    arrowRedraw();
    // console.log("echart options set 1")


    window.addEventListener('resize', function() {
        myChart.resize();
        arrowRedraw();
    });

    myChart.on('georoam', function() {
        arrowRedraw();
    });




    // --- slider setup: 1960 .. (current year + 1) ---
    const sliderEl = document.getElementById('yearSlider');
    const labelEl  = document.getElementById('yearLabel');

    sliderEl.max        = String(currentYear+1);
    sliderEl.value      = String(currentYear);
    labelEl.textContent = sliderEl.value;


    function subtractMonths(year, month, steps) {
      let newYear  = year;
      let newMonth = month;
      for (let idx1 = 0; idx1 < steps; idx1 += 1) {
        newMonth -= 1;
        if (newMonth === 0) {
          newMonth = 12;
          newYear -= 1;
        }
      }
      const mnthFormatted = `${newMonth}`.padStart(2, "0");
      // return `2025-09`;
      console.log( String(newYear) + "-" + mnthFormatted );
      return String(newYear) + "-" + mnthFormatted;
    }


    function sliderToKey(){

      const yr = parseInt(sliderEl.value, 10);

      if (selectedVar !== "eurostat_yields_10y"){
        return {
          yr: yr,
          lbl:String(yr),
        };
      }

      const mp2 = selectedDataMeta[selectedVar]["selected_data"]["mapping2"]
      // console.log(mp2);
      return {
        yr:  mp2[ String(yr) ],
        lbl: mp2[ yr ],
      };



    }


    sliderEl.addEventListener("wheel", function(evt) {
        evt.preventDefault();               // stop page scrolling
        const direction = Math.sign(evt.deltaY);
        let newValue = Number(sliderEl.value) - direction * wheelStep;

        if (newValue < sliderEl.min) {
            newValue = sliderEl.min;
        }
        if (newValue > sliderEl.max) {
            newValue = sliderEl.max;
        }
        sliderEl.value = newValue;
        sliderEl.dispatchEvent(new Event("input"));    // trigger input event
    });


    // --- onChange handler: update the chart option (stub) ---
    sliderEl.addEventListener('change', function () {

      const res = sliderToKey();
      labelEl.textContent = res.lbl;

      // mutate option and re-apply
      let option3;

      // reset the stuff we want to update
      option3 = {
        series: [],
        geo: {
          regions: [],
        },
      };
      // re-populate
      option3.series = [
        ...manyCountriesShowStats(res.yr),
        ...symbolsSeries(),
      ];
      option3.geo.regions  = [
          ...regionsColoring(res.yr),
          extraRectangle('Cyprus', -14,-34),
          extraRectangle('Malta' ,  -6,-24),
      ];


      console.log(` changing year to ${res.yr} `);
      myChart.setOption(
        option3,
        {
          notMerge :   false,  // do merge
          lazyUpdate : true,
        },
      );
    });




    // color_opacity also triggers the option/radio change event
    const extendableList = Array.from(statRadios);
    const opacityInput   = document.getElementById('color_opacity');
    extendableList.push(opacityInput);


    for (let idx1 = 0; idx1 < extendableList.length; idx1++) {
      extendableList[idx1].addEventListener('change', function (evt) {

        if (evt.target.name === "color_opacity") {
          localStorage.setItem("initOpacity", evt.target.value.toString());
        } else {
          selectedVar  = evt.target.value;
        }

        console.log(`selected ${evt.target.value}`);

        linkDownload.setAttribute("href", `/static/dl/${selectedVar}.csv`)

        createGradientLegend( "myGradient2", selectedDataMeta[selectedVar]);


        const res = sliderToKey();
        labelEl.textContent = res.lbl;

        // mutate option and re-apply
        let option4;

        // reset the stuff we want to update
        option4 = {
          series: [],
          geo: {
            regions: [],
          },
        };
        // re-populate
        option4.series = [
          ...manyCountriesShowStats(res.yr),
          ...symbolsSeries(),
        ];
        option4.geo.regions  = [
            ...regionsColoring(res.yr),
            extraRectangle('Cyprus', -14,-34),
            extraRectangle('Malta' ,  -6,-24),
        ];

        myChart.setOption(
          option4,
          {
            notMerge :   false,  // do merge
            lazyUpdate : true,
          },
        );

      });
    }


    document.getElementById("linkPlay").addEventListener("click", function (ev) {
        ev.preventDefault();

        const sliderElem = document.getElementById("yearSlider");
        const minVal = parseInt(sliderElem.min, 10);
        const maxVal = parseInt(sliderElem.max, 10);

        let currentVal = minVal;
        sliderElem.value = currentVal;
        sliderElem.dispatchEvent(new Event("change"));

        const stepTimer = setInterval(function () {

            currentVal += 1;
            sliderElem.value = currentVal;
            // we need to send the event to slider - to trigger its change event
            sliderElem.dispatchEvent(new Event("change"));

            if (currentVal >= maxVal) {
                clearInterval(stepTimer);
            }

        }, 550);
    });




  })();   // end of outmost aync func - so we can you fetch inside




</script>







<script>

    function buildTicks(elParent, color_ranges, minValue, maxValue, fullRange) {

        // remove old ticks
        const oldTicks = elParent.querySelectorAll(".tick");
        for (let idx1 = 0; idx1 < oldTicks.length; idx1 += 1) {
            oldTicks[idx1].remove();
        }

        const tickValuesSet = new Set();

        // ticks when hue changes
        for (let idx1 = 0; idx1 < color_ranges.length; idx1 += 1) {
            // tickValuesSet.add(color_ranges[idx1]);
            // console.log(` tick  at hue boundary  ${color_ranges[idx1]}`)
        }

        // ticks depending on range size
        if (fullRange < 6) {
            // every full number
            const sttInt = Math.ceil( minValue);
            const endInt = Math.floor(maxValue);

            for (let curVal = sttInt; curVal <= endInt; curVal += 1) {
                console.log(` tick-range-6 at ${curVal}`)
                tickValuesSet.add(curVal);
            }

        } else if (fullRange <= 10) {
            // every even number
            const sttEven = Math.ceil( minValue / 2) * 2;
            const endEven = Math.floor(maxValue / 2) * 2;

            for (let curVal = sttEven; curVal <= endEven; curVal += 2) {
                console.log(` tick-range-10 at ${curVal}`)
                tickValuesSet.add(curVal);
            }

        } else {
            // every 20% of the full range (0, 20, 40, 60, 80, 100%)

            const sttEven = Math.ceil( minValue / 50) * 50;
            const endEven = Math.floor(maxValue / 50) * 50;

            for (let curVal = sttEven; curVal <= endEven; curVal += 50) {
                console.log(` tick-range-xx at ${curVal}`)
                tickValuesSet.add(curVal);
            }

        }


        const tickValues = Array.from(tickValuesSet).sort((a, b) => a - b);
        for (let idx1 = 0; idx1 < tickValues.length; idx1 += 1) {

            const value = tickValues[idx1];
            const positionPercent = (value - minValue) / fullRange * 100;
            if (positionPercent < 0 || positionPercent > 100) {
                continue;
            }
            const tickElement = document.createElement("div");
            tickElement.className = "tick";
            tickElement.style.left = positionPercent + "%";
            tickElement.textContent = value + "%";
            elParent.appendChild(tickElement);
        }
    }

    function gradientCss(gradientElement, color_ranges, colors, minValue, maxValue, fullRange) {

        const stops = [];

        for (let idx1 = 0; idx1 < color_ranges.length; idx1 += 1) {

            const boundaryValue   = color_ranges[idx1];
            const pct = (boundaryValue - minValue) / fullRange * 100;
            const positionPercent = Math.round(pct*10)/10;

            // previous color up to boundary
            stops.push(colors[idx1] + " " + positionPercent + "%");
            // hard edge: next color starts at same position
            stops.push(colors[idx1] + " " + positionPercent + "%");
        }

        // ensure last color reaches 100%
        stops.push(colors[colors.length - 1] + " 100%");

        const gradientCss = "linear-gradient( \n\tto right, \n\t" + stops.join(", \n\t") + "\n)";
        console.log(`background:  ${gradientCss};`)
        gradientElement.style.background = gradientCss;
    }



    function createGradientLegend(domEl, config) {

        const elGradient = document.getElementById(domEl);
        const elParent   = elGradient.parentElement;

        const color_ranges = config.color_ranges.slice().sort((a, b) => a - b);  // ensure ascending
        const colors       = config.colors;

        if (colors.length !== color_ranges.length) {
            console.error("colors.length must equal color_ranges.length");
            return;
        }

        const minValue  = color_ranges[0];
        const maxValue  = color_ranges[color_ranges.length - 1];
        const fullRange = maxValue - minValue;

        gradientCss(elGradient, color_ranges, colors, minValue, maxValue, fullRange);

        buildTicks(elParent, color_ranges, minValue, maxValue, fullRange);

    }


</script>

